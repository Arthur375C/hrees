class Hrees {
  constructor(gravity = 0.98) {
    this.gravity = gravity;
    this.objects = [];
    this.particles = [];
    this.triggers = [];
    this.sounds = {};
    this.scenes = {};
    this.currentScene = null;
    this.cameraTarget = null;
    this.cameraOffset = { x: 0, y: 0 };
    this.tilemaps = []; // ✅ inicializado
  }

  // ================== Objetos ==================
  addObject(obj) {
    obj.vx = obj.vx || 0;
    obj.vy = obj.vy || 0;
    obj.ax = 0;
    obj.ay = 0;
    obj.rotation = obj.rotation || 0;
    obj.angularVelocity = obj.angularVelocity || 0;
    obj.friction = obj.friction || 0.99;
    obj.elasticity = obj.elasticity || 0.7;
    obj.mass = obj.mass || 1;
    obj.type = obj.type || 'rect';
    obj.width = obj.width || 50;
    obj.height = obj.height || 50;
    obj.radius = obj.radius || 25;
    obj.color = obj.color || 'red';
    obj.canvasWidth = obj.canvasWidth || 600;
    obj.canvasHeight = obj.canvasHeight || 400;
    this.objects.push(obj);
  }

  addRect(x, y, w, h, options = {}) {
    this.addObject(Object.assign({ x, y, width: w, height: h, type: 'rect' }, options));
  }

  addCircle(x, y, r, options = {}) {
    this.addObject(Object.assign({ x, y, radius: r, type: 'circle' }, options));
  }

  addImage(path, options = {}) {
    const img = new Image();
    img.src = path;
    this.addObject(Object.assign({
      x: options.x || 0,
      y: options.y || 0,
      width: options.width || 50,
      height: options.height || 50,
      type: 'image',
      image: img
    }, options));
  }

  addText(text, options = {}) {
    this.addObject(Object.assign({
      x: options.x || 0,
      y: options.y || 0,
      type: 'text',
      text: text,
      font: options.font || '20px Arial',
      color: options.color || 'black'
    }, options));
  }

  addParticle(p) {
    p.vx = p.vx || 0;
    p.vy = p.vy || 0;
    p.life = p.life || 100;
    p.size = p.size || 5;
    p.color = p.color || 'yellow';
    this.particles.push(p);
  }

  addTrigger(x, y, w, h, callback) {
    this.triggers.push({ x, y, w, h, callback });
  }

  // ================== Tilemap ==================
  addTilemap(map, tileWidth = 50, tileHeight = 50, options = {}) {
    const tm = { map, tileWidth, tileHeight, options };
    this.tilemaps.push(tm);

    for (let y = 0; y < map.length; y++) {
      for (let x = 0; x < map[y].length; x++) {
        const tile = map[y][x];
        if (tile) {
          this.addRect(
            x * tileWidth,
            y * tileHeight,
            tileWidth,
            tileHeight,
            Object.assign({ color: 'grey' }, options)
          );
        }
      }
    }
  }

  renderTilemaps(ctx) {
    for (let tm of this.tilemaps) {
      for (let y = 0; y < tm.map.length; y++) {
        for (let x = 0; x < tm.map[y].length; x++) {
          const tile = tm.map[y][x];
          if (tile) {
            ctx.fillStyle = tm.options.color || 'brown';
            ctx.fillRect(x * tm.tileWidth, y * tm.tileHeight, tm.tileWidth, tm.tileHeight);
          }
        }
      }
    }
  }

  // ================== Som ==================
  loadSound(name, path) {
    const audio = new Audio(path);
    this.sounds[name] = audio;
  }

  playSound(name) {
    if (this.sounds[name]) this.sounds[name].play();
  }

  // ================== Scenes ==================
  addScene(name, objects = []) {
    this.scenes[name] = objects;
  }

  loadScene(name) {
    if (this.scenes[name]) {
      this.objects = this.scenes[name].slice();
      this.currentScene = name;
    }
  }

  // ================== Câmera ==================
  setCamera(target, offset = { x: 0, y: 0 }) {
    this.cameraTarget = target;
    this.cameraOffset = offset;
  }

  follow(target) {
    if (this.cameraTarget) {
      this.cameraOffset.x = target.x - 300;
      this.cameraOffset.y = target.y - 200;
    }
  }

  // ================== Física ==================
  applyGravity() {
    for (let obj of this.objects) {
      obj.vy += this.gravity;
    }
  }

  applyForces(obj, fx, fy) {
    obj.vx += fx / obj.mass;
    obj.vy += fy / obj.mass;
  }

  handleCollisions() {
    for (let obj of this.objects) {
      if (obj.type === 'rect') {
        if (obj.y + obj.height > obj.canvasHeight) { obj.y = obj.canvasHeight - obj.height; obj.vy *= -obj.elasticity; }
        if (obj.y < 0) { obj.y = 0; obj.vy *= -obj.elasticity; }
        if (obj.x < 0) { obj.x = 0; obj.vx *= -obj.elasticity; }
        if (obj.x + obj.width > obj.canvasWidth) { obj.x = obj.canvasWidth - obj.width; obj.vx *= -obj.elasticity; }
      } else if (obj.type === 'circle') {
        if (obj.y + obj.radius > obj.canvasHeight) { obj.y = obj.canvasHeight - obj.radius; obj.vy *= -obj.elasticity; }
        if (obj.y - obj.radius < 0) { obj.y = obj.radius; obj.vy *= -obj.elasticity; }
        if (obj.x - obj.radius < 0) { obj.x = obj.radius; obj.vx *= -obj.elasticity; }
        if (obj.x + obj.radius > obj.canvasWidth) { obj.x = obj.canvasWidth - obj.radius; obj.vx *= -obj.elasticity; }
      }
    }

    for (let i = 0; i < this.objects.length; i++) {
      for (let j = i + 1; j < this.objects.length; j++) {
        let a = this.objects[i], b = this.objects[j];
        if (a.type === 'rect' && b.type === 'rect') {
          if (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y) {
            [a.vx, b.vx] = [b.vx * a.elasticity, a.vx * b.elasticity];
            [a.vy, b.vy] = [b.vy * a.elasticity, a.vy * b.elasticity];
          }
        }
      }
    }
  }

  // ================== Partículas ==================
  updateParticles() {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.vy += this.gravity * 0.1;
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      if (p.life <= 0) this.particles.splice(i, 1);
    }
  }

  // ================== Atualização ==================
  update() {
    this.applyGravity();
    for (let obj of this.objects) {
      obj.vx *= obj.friction;
      obj.vy *= obj.friction;
      obj.x += obj.vx;
      obj.y += obj.vy;
      obj.rotation += obj.angularVelocity;
    }

    this.handleCollisions();
    this.updateParticles();

    // Triggers
    for (let t of this.triggers) {
      for (let o of this.objects) {
        if (o.x + t.w > t.x && o.x < t.x + t.w && o.y + t.h > t.y && o.y < t.y + t.h) {
          t.callback(o);
        }
      }
    }
  }

  // ================== Render ==================
  render(ctx) {
    ctx.save();
    if (this.cameraTarget) {
      ctx.translate(-this.cameraOffset.x, -this.cameraOffset.y);
    }

    this.renderTilemaps(ctx); // ✅ renderiza tilemaps antes dos objetos

    for (let obj of this.objects) {
      ctx.save();
      ctx.translate(obj.x + (obj.type === 'rect' ? obj.width / 2 : 0), obj.y + (obj.type === 'rect' ? obj.height / 2 : 0));
      ctx.rotate(obj.rotation);
      if (obj.type === 'rect') { ctx.fillStyle = obj.color; ctx.fillRect(-obj.width / 2, -obj.height / 2, obj.width, obj.height); }
      else if (obj.type === 'circle') { ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(0, 0, obj.radius, 0, 2 * Math.PI); ctx.fill(); }
      else if (obj.type === 'image' && obj.image.complete) { ctx.drawImage(obj.image, -obj.width / 2, -obj.height / 2, obj.width, obj.height); }
      else if (obj.type === 'text') { ctx.fillStyle = obj.color; ctx.font = obj.font; ctx.fillText(obj.text, -obj.width / 2, -obj.height / 2); }
      ctx.restore();
    }

    for (let p of this.particles) {
      ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
    }

    ctx.restore();
  }

  // ================== Save / Load ==================
  save() {
    return JSON.stringify({ objects: this.objects, particles: this.particles, triggers: this.triggers, tilemaps: this.tilemaps });
  }

  load(json) {
    const data = JSON.parse(json);
    this.objects = data.objects;
    this.particles = data.particles;
    this.triggers = data.triggers;
    this.tilemaps = data.tilemaps || [];
  }
}
